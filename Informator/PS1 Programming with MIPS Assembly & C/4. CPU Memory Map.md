![[Pasted image 20250813112907.png]]

- **Memory Mapping Concept**
    
    - For the CPU to interact with various components like the **GPU, SPU, CD controller, and I/O ports**, these devices need to be **memory-mapped**.
    - This means they are assigned specific addresses within the CPU's overall memory space.
    - When the CPU wants to send data (poke values) or read status from these components, it writes or reads to their corresponding memory-mapped addresses.
- **Key Memory Regions and Addresses**
    
    - The total memory space includes not only RAM but also memory-mapped hardware components [source previously provided in our conversation].
    - **Main RAM**:
        - **2 megabytes (2048 kilobytes)** of main RAM.
        - Mapped to addresses starting at `0x00000000`, `0x80000000`, and `0xA0000000`.
        - The **first 64 kilobytes are reserved for the PlayStation BIOS**.
    - **Scratchpad (Fast RAM)**:
        - A type of **data cache that functions as fast RAM**.
        - **1 kilobyte** in size.
        - Programmers can use this for operations requiring speed.
        - Mapped to the starting address **`0x1F800000`**.
    - **I/O Ports**:
        - These are crucial addresses where various external components and their registers are mapped.
        - Starts at **`0x1F801000`**.
        - Includes registers for the **GPU, SPU control, and MDEC**.
    - **Expansion Region 1 (ROM and RAM)**:
        - **8,192 kilobytes** in size.
        - Mapped to specific addresses (details not provided, but generally in the `0x1F000000` range).
    - **Expansion Region 2**:
        - **8 kilobytes** in size.
        - Mapped to specific addresses (details not provided).
    - **Expansion Region 3 (General Purpose)**:
        - **2 megabytes** in size.
        - Mapped to specific addresses (details not provided).
    - **BIOS ROM Kernel**:
        - **512 kilobytes** in size.
        - Mapped to specific addresses (details not provided).
- **Memory Segments (Kernel vs. User Memory)**
    
    - The PlayStation's memory is divided into **kernel memory** and **user memory**.
    - **Kernel Memory**: Located in the **upper 2 gigabytes**.
        - **KSEG1**: Represents **normal physical memory with cache disabled** (uncached).
        - **KSEG0**: A **mirror of KSEG1, but with cache enabled**.
    - **User Memory (KUSEG)**: Located in the **lower 2 gigabytes**.
        - On the PlayStation (PS1), **only the first 512 megabytes of user memory are addressable**.
        - Since the PS1 **does not support virtual memory** (as mentioned in a previous source), KUSEG simply contains a mirror of KSEG0 and KSEG1 within its addressable 512 MB range.
        - In other MIPS processors, KUSEG regions are intended for 2 GB of virtual memory.
- **Examples of I/O Port Registers (Starting at `0x1F80xxxx`)**
    
    - **GPU Registers**:
        - **GP0 (`0x1F801810`)**: Used to **send commands and packets of information** for rendering, such as triangle vertices, shading types, and colours. Writing data to this address controls GPU rendering instructions.
        - **GP1 (`0x1F801814`)**: Used for **display control** and configuration. Writing to this address can **reset the GPU**, configure resolution, bit depth, NTSC/PAL settings.
        - **GPU Read (`0x1F801810`)**: Reading from this address (the same as GP0) retrieves the GPU's response to GP0 and GP1 commands.
        - **GPU Status (`0x1F801814`)**: Reading from this address (the same as GP1) provides the GPU's status, indicating if it's active, inactive, or has issues.
    - **SPU (Sound Processing Unit) Control Registers**:
        - Mapped within the I/O ports section.
        - Specific addresses control features like **main volume (left/right)**, reverb output volume, voice keying (on/off), attack, decay, and sustain.
    - **MDEC (Motion Decoder) Registers**:
        - Also mapped within the I/O ports.
        - Includes addresses for sending MDEC command parameters, controlling resets, and reading data responses.
- **Programming Implications**
    
    - Programmers directly instruct the CPU to load and store values.
    - Understanding the memory map is crucial for writing assembly code, as it defines the addresses where data can be stored in RAM, and where to write/read to control memory-mapped hardware components.
    - The CPU communicates with all these memory-mapped devices via the bus.